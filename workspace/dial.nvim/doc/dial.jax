*dial.txt* CTRL-A / CTRL-X を拡張するLua製プラグイン

Vimの標準機能である CTRL-A / CTRL-X を拡張し、英数字に限らない様々な文字列を
インクリメント/デクリメントできるようにするパッケージです。

Author: Mogami Shinichi (@monaqa) <cmonaqa{at}google.com>
Version: 0.3.0
License: MIT license
		<https://github.com/monaqa/dial.nvim/blob/master/LICENSE>

==============================================================================
CONTENTS								*dial-contents*

Requirements					|dial-requirements|
Introduction					|dial-introduction|
  Features						|dial-features|
Usage							|dial-usage|
Configurations					|dial-config|
  Aliases						|dial-aliases|
  Augends						|dial-augends|
    Number						|dial-augends-number|
    Date						|dial-augends-date|
    Constant					|dial-augends-constant|
    Case						|dial-augends-case|
    Hexcolor					|dial-augends-hexcolor|
    Semver						|dial-augends-semver|
    Paren						|dial-augends-paren|
    Misc						|dial-augends-misc|
    User						|dial-augends-user|
Advanced Usage					|dial-advanced-usage|
  Dot Repeating					|dial-dot-repeating|
Interface						|dial-interface|
  Mapping						|dial-mapping|
  Command						|dial-command|
  Lua API						|dial-lua-api|

==============================================================================
REQUIREMENTS							*dial-requirements*

* Neovim 0.6.1 or later（0.5.0 以降なら動くと考えられますが保証はしません）

==============================================================================
INTRODUCTION							*dial-introduction*

*dial.nvim* は、様々な形式の文字列をインクリメント/デクリメントするパッケージ
です。標準の CTRL-A や CTRL-X、 g CTRL-A といったコマンドの動作を拡張します。

------------------------------------------------------------------------------
FEATURES								*dial-features*

多岐にわたる文字列の増減~
	以下のように、さまざまな文字列を増減できます。

	* n 進数 (`2 <= n <= 36`) の整数
	* 日付
	* キーワードや演算子など、所定文字列のトグル
	  * `true` ⇄ `false`
	  * `&&` ⇄ `||`
	  * `a` ⇄ `b` ⇄ ... ⇄ `z`
	  * `日` ⇄ `月` ⇄ ... ⇄ `土` ⇄ `日` ⇄ ...
	* 識別子の命名規則 (camelCase, snake_case, etc.)
	* Hex color
	* SemVer

	カスタムルールに基づく増減ルールを設定することも可能です。

増減対象の (augend) の柔軟な設定~
	|dial.nvim| が提供する増減ルールは多岐にわたりますが、ユーザは本当に必要な
	ものだけを選択して有効化することができます。
	競合するルール（例: `mm/dd/yyyy`形式の日付と`dd/mm/yyyy`形式の日付）がある
	場合も、片方だけを有効化することによって取り違えることなく増減操作を行うこ
	とができます。
	特定のバッファやファイルタイプでのみ増減対象を変更することも可能です。

カウンタへの対応~
	通常の CTRL-A / CTRL-X と同様に、 `10<C-a>` のように打つことで加数を変更で
	きます。

ドットリピートへの対応~
	通常の CTRL-A / CTRL-X と同様に、|.| を用いて直前の操作を繰り返せます。
	|dial.nvim| では直前の増減対象を記憶しており、たとえば直前に「`yyyy/mm/dd`
	形式の月」をインクリメントしていた場合は、たとえより手前に他の増減対象文字
	列があったとしても「`yyyy/mm/dd`形式の月」を探してインクリメントします。

VISUAL mode での操作に対応~
	標準の CTRL-A や CTRL-X は VISUAL モードでも用いることができますが、同様
	の機能を dial.nvim も備えています。 |v_g_CTRL-A| や |v_g_CTRL-X| にも対応
	しています。NORMAL モードとVISUAL モードで増減対象を変えることもできます。

==============================================================================
USAGE									*dial-usage*

|dial.nvim|自信はキーマップの設定および上書きを行わないため、プラグインを動作
させるために以下の設定を追加する必要があります。
>
	nmap  <C-a>  <Plug>(dial-increment)
	nmap  <C-x>  <Plug>(dial-decrement)
	vmap  <C-a>  <Plug>(dial-increment)
	vmap  <C-x>  <Plug>(dial-decrement)
	vmap g<C-a> g<Plug>(dial-increment)
	vmap g<C-x> g<Plug>(dial-decrement)
<

もしくは Lua 上で以下のように設定することもできます。

>
	vim.api.nvim_set_keymap(
		"n", "<C-a>", require("dial.map").inc_normal(), {noremap = true}
	)
	vim.api.nvim_set_keymap(
		"n", "<C-x>", require("dial.map").dec_normal(), {noremap = true}
	)
	vim.api.nvim_set_keymap(
		"v", "<C-a>", require("dial.map").inc_visual(), {noremap = true}
	)
	vim.api.nvim_set_keymap(
		"v", "<C-x>", require("dial.map").dec_visual(), {noremap = true}
	)
	vim.api.nvim_set_keymap(
		"v", "g<C-a>", require("dial.map").inc_gvisual(), {noremap = true}
	)
	vim.api.nvim_set_keymap(
		"v", "g<C-x>", require("dial.map").dec_gvisual(), {noremap = true}
	)
<

==============================================================================
CONFIGURATIONS							*dial-config*

dial.nvim では操作対象を表す被加数 (augend) と、複数の被加数をまとめたグループ
を用いることで、増減ルールを自由に設定することができます。

>
	local augend = require("dial.augend")
	require("dial.config").augends:register_group{
	  -- グループ名を指定しない場合に用いられる被加数
	  default = {
		augend.integer.alias.decimal,   -- nonnegative decimal number
		augend.integer.alias.hex,       -- nonnegative hex number
		augend.date.alias["%Y/%m/%d"],  -- date (2022/02/19, etc.)
	  },

	  -- `mygroup` というグループ名を使用した際に用いられる被加数
	  mygroup = {
		augend.integer.alias.decimal,
		augend.constant.alias.bool,    -- boolean value (true <-> false)
		augend.date.alias["%m/%d/%Y"], -- date (02/19/2022, etc.)
	  }
	}
<

`"dial.config"` モジュールに存在する `augends:register_group` 関数を用いてグル
ープを定義することができます。関数の引数には、グループ名をキー、被加数のリスト
を値とする辞書を指定します。

上の例で `augend` という名前のローカル変数に代入されている `"dial.augend"`
モジュールにはさまざまな被加数が定義されています。具体的に定義されている被加数
とエイリアスについては |dial-augends| および |dial-aliases| を参照。

|dial.nvim| では以下のように **expression register** |@=| を用いることで増減対
象のグループを指定します。
>
	"=mygroup<CR><C-a>
<

増減のたびに expression register を指定するのが面倒であれば、以下のようにマッ
ピングすることも可能です。
>
	nmap <Leader>a "=mygroup<CR><Plug>(dial-increment)
<

Lua 上で以下のように記述すれば expression register を使わずマッピングを設定で
きます。

>
	vim.api.nvim_set_keymap(
		"n",
		"<Leader>a",
		require("dial.map").inc_normal("mygroup"),
		{noremap = true}
	)
<

										*dial-config-augends-default*
デフォルトグループ~

`default` は特殊なグループであり、標準で定義されています。expression register
などでグループ名を指定しなかった場合は `default` グループにある被加数がかわり
に用いられます。

何も設定しなかった場合は以下の設定を行っているのと等価となります。

>
	local augend = require("dial.augend")
	require("dial.config").augends:register_group{
	  default = {
		augend.integer.alias.decimal,
		augend.integer.alias.hex,
		augend.date.alias["%Y/%m/%d"],
		augend.date.alias["%Y-%m-%d"],
		augend.date.alias["%m/%d"],
		augend.date.alias["%H:%M"],
		augend.constant.alias.ja_weekday_full,
	  },
	}
<

VISUAL mode 限定のマッピング~

VISUAL モード用のグループを作成することで可能です。

>
	local augend = require("dial.augend")
	require("dial.config").augends:register_group{
	  visual = {
		augend.integer.alias.decimal,
		augend.integer.alias.hex,
		augend.date.alias["%Y/%m/%d"],
		augend.constant.alias.alpha,
		augend.constant.alias.Alpha,
	  },
	}

	-- VISUAL モードでの被加数を変更する
	vim.api.nvim_set_keymap(
		"v", "<C-a>", require("dial.map").inc_normal("visual"), {noremap = true}
	)
	vim.api.nvim_set_keymap(
		"v", "<C-x>", require("dial.map").dec_normal("visual"), {noremap = true}
	)
<

特定のファイルタイプ限定のマッピング~

特定のファイルタイプ用のグループを作成し、 |autocmd| でバッファごとにキーマッ
ピングを設定することで実現できます。

>
	lua << EOF
	local augend = require("dial.augend")
	require("dial.config").augends:register_group{
	  typescript = {
		augend.integer.alias.decimal,
		augend.integer.alias.hex,
		augend.constant.new{ elements = {"let", "const"} },
	  },
	}
	EOF

	" 特定のファイルタイプでのみ有効にする
	autocmd FileType typescript nmap <C-a> "=typescript<CR><Plug>(dial-increment)
	autocmd FileType typescript nmap <C-x> "=typescript<CR><Plug>(dial-decrement)
<

------------------------------------------------------------------------------
ALIASES									*dial-aliases*

被加数のエイリアスとして、デフォルトで以下が提供されています。
詳しくは |dial-augends| の対応する節を参照。

	integer:
		`augend.integer.alias.decimal`
		`augend.integer.alias.decimal_int`
		`augend.integer.alias.hex`
		`augend.integer.alias.octal`
		`augend.integer.alias.binary`

	date:
		`augend.date.alias["%Y/%m/%d"]`
		`augend.date.alias["%m/%d/%Y"]`
		`augend.date.alias["%d/%m/%Y"]`
		`augend.date.alias["%m/%d/%y"]`
		`augend.date.alias["%d/%m/%y"]`
		`augend.date.alias["%m/%d"]`
		`augend.date.alias["%-m/%-d"]`
		`augend.date.alias["%Y-%m-%d"]`
		`augend.date.alias["%Y年%-m月%-d日"]`
		`augend.date.alias["%Y年%-m月%-d日(%ja)"]`
		`augend.date.alias["%H:%M:%S"]`
		`augend.date.alias["%H:%M"]`

	constant:
		`augend.constant.alias.ja_weekday`
		`augend.constant.alias.ja_weekday_full`
		`augend.constant.alias.bool`
		`augend.constant.alias.alpha`
		`augend.constant.alias.Alpha`

	semver:
		`augend.semver.alias.semver`

------------------------------------------------------------------------------
AUGENDS									*dial-augends*

以下簡単のため、 `augend` という変数は以下のように定義されているものとします。

>
	local augend = require("dial.augend")
<

NUMBER									*dial-augends-number*
------

n 進数の整数 (`2 <= n <= 36`) を表します。 `augend.integer.new{ ...opts }` で
使用できます。

>
	require("dial.config").augends:register_group{
	  default = {
		-- uppercase hex number (0x1A1A, 0xEEFE, etc.)
		augend.integer.new{
		  radix = 16,
		  prefix = "0x",
		  natural = true,
		  case = "upper",
		},
	  },
	}
<

`augend.integer.new` の引数のテーブルは以下のキーをとることができます。
		radix (number, default: 10)
				表記に用いる進数を表します。
		prefix (string, default: "")
				数値に前置される文字列を指定できます (e.g. `0x`)。
		natural (boolean, default: true)
				true のときは自然数にのみマッチします。
				つまり、 `-1` のうえにカーソルがあったとしても `1` にマッチし、
				`-1` にはマッチしません。
		case ("upper" | "lower", default: "lower")
				16進数のように10よりも大きな進数のときに用いるアルファベットの
				大文字/小文字を指定します。
		delimiter (char, default: "")
				数値の区切り文字を指定します。たとえば "," を与えると、以下の
				ような数値にもマッチするようになります。
>
					1,234,567
					1,23,4,5,67
<
				いずれも数値を解釈するときは単にカンマが無視されますが、増減時
				にカンマの位置が n 桁区切りとなるよう整形されます。n の値は後
				述する `delimiter_digits` の値で制御できます。
		delimiter_digits (number, default: 3)
				数値の区切り文字が指定されているとき、数値を何桁区切りで表示す
				るか指定します。
				`delimiter` が空文字列のときには意味がありません。

augend.integer.alias.decimal~

十進数の整数。
>
	0
	123
	3141592
<
といった文字列にマッチし、1つインクリメントするごとにその数値を1増加させます。
標準の CTRL-A と異なり、数字の先頭に `-` が付いていても考慮しません。
>
	file-1.jpg
<
という文字列の `1` にカーソルがある状態で |<Plug>(dial-increment)| を行うと
>
	file-2.jpg
<
となります。

augend.integer.alias.decimal_int~

基本的には `augend.integer.alias.decimal` と同じですが、こちらは負の整数にも
マッチします。
>
	file-1.jpg
<
という文字列の `1` にカーソルがある状態で |<Plug>(dial-increment)| を行うと
>
	file0.jpg
<
となります。

augend.integer.alias.hex~

16進数の非負整数にマッチし、16進数の表記でインクリメント・デクリメントが行われ
ます。
>
	0x12
	0xafbf
	0xAFBF
<
などの文字列にマッチします。

augend.integer.alias.octal~

8進数の非負整数にマッチし、8進数の表記でインクリメント・デクリメントが行われま
す。
>
	0o37
	0o567
	0o01212
<
などの文字列にマッチします。

augend.integer.alias.binary~

2進数の非負整数にマッチし、2進数の表記でインクリメント・デクリメントが行われま
す。
>
	0b00
	0b1010
	0b10100101
<
などの文字列にマッチします。

DATE									*dial-augends-date*
-----

日付や時刻を表します。以下のエイリアスから選択します。

augend.date.alias["%Y/%m/%d"]~

以下のようなフォーマットの日付にマッチします。
>
	1970/12/31
	2021/01/01
	2021/02/13
<

カーソルが当該フォーマットより左にある場合は日付単位でのインクリメントが行われ
ますが、カーソルがフォーマット上にある場合、具体的なカーソルの位置によってイン
クリメントの対象が変化します。

`1970/12/31` を例に取ってみます。

`1970` の4文字のいずれかの上にカーソルがあるときにインクリメントを行うと
>
	1971/12/31
<
のように年がインクリメントされます。

`/12` のいずれかの上にカーソルがあるときにインクリメントを行うと
>
	1971/01/31
<
のように月がインクリメントされます。

`/31` のいずれかの上にカーソルがあるときにインクリメントを行うと
>
	1971/01/01
<
のように日付がインクリメントされます。

当該フォーマットでは
>
	2021/02/29
	2021/14/59
<
のように現実には存在しない日付でもマッチするものの、インクリメントを行う際に現
実に存在する日付へと強制的に修正されます。

augend.date.alias["%m/%d/%Y"]~

以下のようなフォーマットの日付にマッチします。
>
	12/31/1970
	01/01/2021
	02/13/2021
<
意図しないマッチを避けるため、存在しない日付にはマッチしません。

augend.date.alias["%d/%m/%Y"]~

以下のようなフォーマットの日付にマッチします。
>
	31/12/1970
	01/01/2021
	13/02/2021
<
意図しないマッチを避けるため、存在しない日付にはマッチしません。

augend.date.alias["%m/%d/%y"]~

以下のようなフォーマットの日付にマッチします。
>
	12/31/70
	01/01/21
	02/13/21
<
意図しないマッチを避けるため、存在しない日付にはマッチしません。

augend.date.alias["%d/%m/%y"]~

以下のようなフォーマットの日付にマッチします。
>
	31/12/19
	01/01/20
	13/02/20
<
意図しないマッチを避けるため、存在しない日付にはマッチしません。

augend.date.alias["%m/%d"]~

以下のような日付にマッチします。

>
	12/31
	01/01
	02/13
<

`12/31` の例の場合、

* カーソルが `12` より左にある場合：日付
* カーソルが `12` のいずれかの上にある場合：月
* カーソルが `/31` のいずれかの上にある場合：日付

がインクリメントされます。

現実に存在しない日付でもマッチし、操作の際に現実に存在する日付へと強制的に修正
されます。

augend.date.alias["%-m/%-d"]~

基本的に |dial-augends-date#[%m/%d]| と同様ですが、こちらは月日が2桁にパディン
グされていなくてもマッチします。すなわち、
>
	12/31
	1/1
	2/13
<
などにマッチします。
意図しないマッチを避けるため、存在しない日付にはマッチしません。

augend.date.alias["%Y-%m-%d"]~

以下のようなフォーマットの日付にマッチします。
>
	1970-12-31
	2021-01-01
	2021-02-13
<
現実に存在しない日付でもマッチし、操作の際に現実に存在する日付へと強制的に修正
されます。

augend.date.alias["%Y年%-m月%-d日"]~

以下のようなフォーマットの日付にマッチします。
>
	1970年12月31日
	2021年1月1日
	2021年2月13日
<

augend.date.alias["%Y年%-m月%-d日(%ja)"]~

以下のようなフォーマットの日付にマッチします。
>
	1970年12月31日(木)
	2021年1月1日(金)
	2021年2月13日(土)
<
日付と曜日の整合性が取れていない場合もマッチし、インクリメント・デクリメントの
際に正しい曜日となるよう自動で修正されます。

augend.date.alias["%H:%M:%S"]~

以下のようなフォーマットの時刻（時:分:秒）にマッチします。
>
	00:00:00
	12:34:56
<

`12:34:56` の例の場合、

* カーソルが `12` より左にある場合：秒
* カーソルが `12` のいずれかの上にある場合：時
* カーソルが `:34` のいずれかの上にある場合：分
* カーソルが `:56` のいずれかの上にある場合：秒

がインクリメントされます。
意図しないマッチを避けるため、存在しない時刻にはマッチしません。

augend.date.alias["%H:%M"]~

以下のようなフォーマットの時刻（時:分）にマッチします。
>
	00:00
	12:34
<

`12:34` の例の場合、

* カーソルが `12` より左にある場合：分
* カーソルが `12` のいずれかの上にある場合：時
* カーソルが `:34` のいずれかの上にある場合：分

がインクリメントされます。
意図しないマッチを避けるため、存在しない時刻にはマッチしません。

CONSTANT								*dial-augends-constant*
--------

キーワードなどの決められた文字列をトグルします。
`augend.constant.new{ ...opts }` で使用できます。
>
	require("dial.config").augends:register_group{
	  default = {
		-- uppercase hex number (0x1A1A, 0xEEFE, etc.)
		augend.constant.new{
		  elements = {"and", "or"},
		  word = true, -- if false, "sand" is incremented into "sor", "doctor" into "doctand", etc.
		  cyclic = true,  -- "or" is incremented into "and".
		},
		augend.constant.new{
		  elements = {"&&", "||"},
		  word = false,
		  cyclic = true,
		},
	  },
	}
<

以下のパラメータを有します。
		elements (string[], 必須)
				相互変換したい文字列のリスト。
		word (boolean, default: true)
				true のとき、elements に一致する文字列が単語の境界にあるときの
				みマッチします。
		cyclic (boolean, default: true)
				true のとき、増減操作を行う際に巡回します。
		preserve_case (boolean, default: false)
				true のとき、アルファベットの大文字・小文字のパターンを保存し
				ての変換を試みます。
		pattern_regexp (string, default: `\C\V\<\(%s\)\>`)
				文字列検索を行う際の正規表現。 elements に指定した文字列を
				`%s` に指定します。

注意: `&&` と `||` のように、記号からなる文字列を相互変換するときは `cyclic`
を false にしてください。
注意: `preserve_case` が true のときは、大文字・小文字を無視して elements に
指定した文字列にマッチします。このとき、文字列が以下の3パターンのいずれかに該
当する場合に限り、大文字・小文字のパターンを保存して文字列を切り替えます。
* 全て小文字の場合（例: `true <-> false`）
* 全て大文字の場合（例: `TRUE <-> FALSE`）
* 先頭のみ大文字の場合（例: `True <-> False`）
それ以外のときは全て小文字に変換します。

augend.constant.alias.ja_weekday~

日本語の曜日名にマッチします。
>
	月
	火
	水
	木
	金
	土
	日
<

それぞれ Vim の意味での単語になっているものに対してマッチするため、「日用品」
など熟語の一部にはマッチしません。

augend.constant.alias.ja_weekday_full~

日本語の曜日名にマッチします。
>
	月曜日
	火曜日
	水曜日
	木曜日
	金曜日
	土曜日
	日曜日
<

こちらは augend.constant.alias.ja_weekday と異なり、単語ではなく文字列としてマ
ッチするため、「毎週火曜日」のように漢字が連なっていてもマッチします。

augend.constant.alias.bool~

`true` または `false` という単語にマッチします。
>
	true
	false
<

augend.constant.alias.alpha~

`a` や `z` など、1つの小文字アルファベットにマッチします。ノーマルモードの場合
はそれ自身が Vim の意味で単語として独立していない限りマッチしません。例えば
>
	(a)
	a.
<
などのように単語として独立した `a` にはマッチしますが、
>
	cafe
	2a
<
のように単語として独立していない `a` にはマッチしません。

なお、インクリメント時に巡回は行われません。すなわち `z` をインクリメントして
も`z` のまま変わらず、 `a` をデクリメントしても `a` のまま変わりません。

augend.constant.alias.Alpha~

`A` や `Z` など、1つの大文字アルファベットにマッチします。

CASE									*dial-augends-case*
-----

camelCase や snake_case といったプログラミング言語における変数名や関数名の規則
を変更します。 `augend.case.new { ...opts }` で使用できます。

>
	require("dial.config").augends:register_group{
	  default = {
		-- uppercase hex number (0x1A1A, 0xEEFE, etc.)
		augend.case.new{
		  types = {"camelCase", "snake_case"},
		  cyclic = true,
		},
	  },
	}
<

以下のパラメータを有します。
		patterns (string[], 必須)
				相互変換したい命名規則のリスト。以下から選択:
					- `camelCase`
					- `snake_case`
					- `kebab-case`
					- `PascalCase`
					- `SCREAMING_SNAKE_CASE`
		cyclic (boolean, default: true)
				true のとき、増減操作を行う際に巡回します。

NOTE: 現時点で、1つの単語のみから構成される識別子には反応しません。たとえば
`dial_nvim` や `dialNvim` には反応しますが、 `dial` という識別子には反応しませ
ん。これは `dial` という識別子だけを見て、それが camelCase なのか snake_case
なのか判別することが不可能だからです。これは PascalCase など他の規則を選んだ場
合も同様であり、 `Dial` や `DIAL` には反応しません。

HEXCOLOR								*dial-augends-hexcolor*
--------

`#000000` や `#ffffff` といった形式の RGB カラーコードを増減します。
`augend.hexcolor.new{ ...opts }` で使用できます。

>
	require("dial.config").augends:register_group{
	  default = {
		augend.hexcolor.new{
		  case = "lower",
		},
	  },
	}
<

得られる被加数は以下のような16進数のカラーコード (#rrggbb) にマッチします。
>
	#1280af
	#808080
	#001351
<

`#1280af` の例の場合、

* カーソルが `#1280af` より左、もしくは `#` 上にある場合： RGB 全て
* カーソルが `12` のいずれかの上にある場合：R
* カーソルが `80` のいずれかの上にある場合：G
* カーソルが `af` のいずれかの上にある場合：B

がインクリメントの対象となります。

SEMVER									*dial-augends-semver*
------

Semantic version を増減します。後述のエイリアスを用います。単なる非負整数のイ
ンクリメントとは以下の点で異なります。

- semver 文字列よりもカーソルが手前にあるときは、パッチバージョンが優先してイ
  ンクリメントされます。
- マイナーバージョンの値が増加したとき、パッチバージョンの値は0にリセットされ
  ます。
- メジャーバージョンの値が増加したとき、マイナー・パッチバージョンの値は0にリ
  セットされます。

augend.semver.alias.semver~

以下のようなバージョンを表す数字の三つ組にマッチします。
>
	0.3.0
	3.9.14
	1.2.3
<

`1.2.3` の例でインクリメントする場合を考えます。

* カーソルが `1` より手前にある場合
  パッチバージョンがインクリメントされ、 `1.2.4` となります。
* カーソルが `1` の上にある場合
  メジャーバージョンがインクリメントされ、 `1.3.0` となります。
* カーソルが `.2` の上にある場合
  マイナーバージョンがインクリメントされ、 `2.0.0` となります。
* カーソルが `.3` の上にある場合
  パッチバージョンがインクリメントされ、 `1.2.4` となります。

なお、デクリメントする場合はメジャー・マイナー・パッチどのバージョンにおいても
下位の数値は変化しません。 `1.2.3` でメジャーバージョンを1デクリメントすると
`0.2.3` となります。

PAREN									*dial-augends-paren*
-----

括弧やクオーテーションで囲まれた文字列を対象とし、括弧の種類を変更します。
`augend.paren.new{ ...opts }` で使用できます。

>
	require("dial.config").augends:register_group{
	  default = {
		augend.paren.new{
		  patterns = {
			{'"', '"'},
			{"[[", "]]"},
			{"[=[", "]=]"},
			{"[==[", "]==]"},
			{"[===[", "]===]"},
		  },
		  nested = false,
		  cyclic = false,
		},
		augend.paren.new{
		  patterns = { {"'", "'"}, {'"', '"'} },
		  nested = false,
		  escape_char = [[\]],
		  cyclic = true,
		},
	  },
	}
<

以下のパラメータを有します。
		patterns (string[][], 必須)
				相互変換したい括弧のペア。
				各要素は string の2つ組であり、開き括弧と閉じ括弧を表します。
		nested (boolean, default: true)
				true のとき、ネストを検出します。
				開き括弧と閉じ括弧の文字列が一致する場合は意味を成しません。
		cyclic (boolean, default: true)
				true のとき、増減操作を行う際に巡回します。
		escape_char (string, default: nil)
				定義されていれば、その文字列を escape char と見做します。
				escape char の直後では、開き括弧や閉じ括弧の字句が無視されます。
				ただし、 escape char が2つ連続で並んだ場合はescape char 自体が
				escape されたものと見做します。

NOTE: 複数行に渡る括弧を検出・操作することはできません。dial.nvim 全体の方針と
して、CTRL-A や CTRL-X による増減操作は1行で完結するものに制限しています。複数
行に渡る括弧の操作は、より括弧操作に特化したプラグインの使用をお勧めします。

augend.paren.alias.quote~

single-quoted literal と double-quoted literal を相互変換します。
`\` はエスケープ文字として扱われます。
>
	"foo" -> 'foo'
	'foo' -> "foo"
	"foo\"" -> 'foo\"'
<

augend.paren.alias.brackets~

3種類の括弧 `()`, `[]`, `{}` を相互変換します。ネストも考慮されます。
>
	(foo) -> [foo] -> {foo} -> (foo) -> ...
<

augend.paren.alias.lua_str_literal~

Lua の string literal 記法を相互変換します。
>
	"foo" -> [[foo]] -> [=[foo]=] -> [==[foo]==] -> [===[foo]===]
<

augend.paren.alias.rust_str_literal~

Rust の string literal 記法を相互変換します。
>
	"foo" -> r#"foo"# -> r##"foo"## -> r###"foo"###
<

MISC									*dial-augends-misc*
-----

`augend.misc.alias` 下に雑多な被加数がまとめて定義されています。

augend.misc.alias.markdown_header~

Markdown のヘッダレベルを増減します。
>
	# Header1
	## Header2
	###### Header6
<

NOTE: augend としては珍しく、カーソルが `#` より後ろにある場合でもマッチします。
ただしその場合、カーソル上またはカーソルの後に他の有効な被加数が存在すればそち
らが優先されます。確実に markdown_header を増減させたければ、カーソルを行頭に
移動させてから操作することをお勧めします。


USER									*dial-augends-user*
-----

ユーザ自身が増減ルールを定義したい場合には `augend.user.new{ ...opts }` を使用
できます。
>
	require("dial.config").augends:register_group{
	  default = {
		-- uppercase hex number (0x1A1A, 0xEEFE, etc.)
		augend.user.new{
		  find = require("dial.augend.common").find_pattern("%d+"),
		  add = function(text, addend, cursor)
			  local n = tonumber(text)
			  n = math.floor(n * (2 ^ addend))
			  text = tostring(n)
			  cursor = #text
			  return {text = text, cursor = cursor}
		  end
		},
	  },
	}
<

==============================================================================
ADVANCED USAGE							*dial-advanced-usage*

|dial.nvim| のうち、発展的ではあるものの便利な機能を紹介します。

------------------------------------------------------------------------------
DOT REPEATING							*dial-dot-repeating*

|dial.nvim| が提供するすべてのキーコマンドはドットリピートに対応しています。
すなわち、"." を押すことによって直前の増減操作を繰り返すことができます。
ただし標準の <C-a> や <C-x> とは若干挙動が異なり、増減ルールが固定されます。

具体的な例として、以下のような設定を考えます。
>
	local augend = require("dial.augend")
	require("dial.config").augends:register_group{
	  default = {
		augend.integer.alias.decimal,
		augend.date.alias["%Y/%m/%d"],
	  },
	}
<
これはすなわち、十進数の数値と `yyyy/MM/dd` 形式の日付が <C-a> によって増減可
能であることを意味します。

さて、以下のような記述が書かれたバッファをイメージしてください。
>
	date: 2020/11/08
	...
	due date of 1st report: 2020/11/23
	...
	due date of 2nd report: 2020/12/21
	...
	date of exam: 2021/01/14
<

このバッファにある全ての期日をちょうど1ヶ月延長しなければならなくなったとしま
す。日付が大量にある場合この操作はきわめて退屈で面倒ですが、 |dial.nvim| を用
いればとても Vim らしいアプローチで楽にこの操作を実現することができます。

まずはいつもどおり1行目の `2020/11/08` の `11` のところにジャンプし、 <C-a> を
タイプして日付を1ヶ月伸ばします。`2020/12/08` となったはずです。

次に "/" コマンドを用いて `date` で検索し、3行目にジャンプします。
検索文字列はなんでもよいのですが、変更したい日付の前にはいずれも `date` がある
ことから、`date` にジャンプするのが今回は最も楽だと期待できます。
ジャンプしたら、その直後で "." コマンドを実行してください。なんの問題もなく、
`2020/11/23` が1ヶ月延期されるはずです。
>
	date: 2020/12/08
	...
	Due date (1st lecture): 2020/12/23
	...
	Due date (2nd lecture): 2020/12/21
	...
	Due date (3rd lecture): 2021/01/14
<
ここで重要なのは、もしここで "." ではなく <C-a> を押していた場合、 `1st` と書
かれた数字が増減の対象となってしまい、 `2st` になってしまっていたという点です。
仮に `1st` という文字列がなかったとしても、（カーソル位置が `11` にないため）
日付が1日延長されるだけだったでしょう。
<C-a> はコマンドが実行されるたびにその行について適切なルールを探すものの、ドッ
トリピートを行った場合は以前に行ったルールを保持します。ここでは「日付を1ヶ月
延ばす」という操作を保持していたため、カーソルを適切な位置に移動させずとも、自
動的に近くにある日付の「月」のところまで移動してから増減操作を実行します。
したがって上の例では、ひとたび検索を行った後であれば `.n.n.` とするだけですべ
ての期限を1ヶ月延ばすことができるのです。

==============================================================================
INTERFACE								*dial-interface*

------------------------------------------------------------------------------
MAPPING									*dial-mapping*

["x]<Plug>(dial-increment)				*<Plug>(dial-increment)*
	NORMAL モードにおける CTRL-A に相当する機能を提供します。
	すなわち、カーソル下または後の被加数を [count] だけインクリメントします。
	カーソルと同じ行にある被加数のみが対象です。カーソルより手前にある被加数に
	は基本的に反応しないものの、被加数によっては例外的にカーソルの手前にあって
	もインクリメントを行う場合があります。

	expression register |@=| を指定することができ、その場合は記述したグループ
	名に基づく被加数が用いられます。指定しなかった場合は `default` という名前
	のグループに記述された被加数が用いられます(|dial-config-augends-default|)。
	それ以外のレジスタを指定しても効果はありません。

{VISUAL}["x]<Plug>(dial-increment)		*v_<Plug>(dial-increment)*
	NORMAL モードにおける CTRL-A に相当する機能を提供します。
	以下のどのモードに入っているかによって挙動が変化します。
	* 通常の VISUAL モード (|v|)
	* 行 VISUAL モード (|V|)
	* 矩形 VISUAL モード (|CTRL-V|)

	通常のビジュアルモード (|v|) の場合、ビジュアル選択されたテキストの中に含
	まれる被加数を [count] だけインクリメントします。既存の CTRL-A コマンドの
	代替です。

	行選択ビジュアルモード (|V|) の場合、ビジュアル行選択されたテキスト中の被
	加数を、行ごとに [count] だけインクリメントします。各行ごとに被加数の位置
	を探索し、マッチしたもののうち最も手前の被加数を一つだけ対象とします。

	矩形選択ビジュアルモード (|CTRL-V|) の場合は行選択ビジュアルモードの場合と
	似ているものの、マッチする対象が矩形選択された範囲に絞られます。

["x]<Plug>(dial-decrement)				*<Plug>(dial-decrement)*
	NORMAL モードにおける CTRL-X に相当する機能を提供します。

{VISUAL}["x]<Plug>(dial-decrement)		*v_<Plug>(dial-decrement)*
	VISUAL モードにおける CTRL-X に相当する機能を提供します。

{VISUAL}["x]g<Plug>(dial-increment)		*v_g<Plug>(dial-increment)*
	VISUAL モードにおける |v_g_CTRL-A| に相当する機能を提供します。

	使用方法は|v_<Plug>(dial-increment)| と似ているものの、上から数えてn行目に
	ある被加数がn * [count] だけ増加します。箇条書きや予定表など、 一定の数値
	ずつ増加する等差数列を作成したい場合に便利です。たとえば
>
		09/12
		09/12
		09/12
		09/12
<
	という日付のリストがある時、2番目の `1/1` へと移動して下3行を行選択ビジュ
	アルモードで選択し、 `7g<C-a>` と押すと
>
		09/12
		09/19
		09/26
		10/03
<
	のように、1週間ごとの日付が得られます（日付の被加数が有効のときに限る）。

{VISUAL}["x]g<Plug>(dial-decrement)		*v_g<Plug>(dial-decrement)*
	VISUAL モードにおける |v_g_CTRL-X| に相当する機能を提供します。

------------------------------------------------------------------------------
COMMAND									*dial-command*

:[range]DialIncrement {augend}			*:DialIncrement*

	選択範囲に対して、{augend} で指定された被加数を1だけインクリメントします。
	行選択ビジュアルモードにおける |v_<Plug>(dial-increment)| と似ていますが、
	被加数を指定し、そのルールに制限することができます。
	加数（いくつ増加させるか）を指定することはできないため、 |@:| などを用いて
	繰り返すことが想定されています。

:[range]DialDecrement {augend}			*:DialDecrement*

	選択範囲に対して、{augend} で指定された被加数を1だけデクリメントします。

------------------------------------------------------------------------------
LUA API									*dial-lua-api*

										*dial-lua-api-map*
"dial.map" module~

|dial.nvim| 固有のマッピングを提供するモジュールです。

										*dial.map.inc_normal()*
require("dial.map").inc_normal([group_name])

	NORMAL モードにおいて与えられたグループ名をもとにインクリメントを行うため
	のキーシーケンスを出力します。group_name は省略すると `default` と等価にな
	ります。|vim.api| と|nvim_set_keymap| や |nvim_buf_set_keymap| を組み合わ
	せて以下のような形で使用することが想定されています。
>
	vim.api.nvim_set_keymap(
		"n", "<C-a>", require("dial.map").inc_normal(), {noremap = true}
	)
<

										*dial.map.dec_normal()*
require("dial.map").dec_normal([group_name])

	NORMAL モードにおいて与えられたグループ名をもとにデクリメントを行うための
	キーシーケンスを出力します。

										*dial.map.inc_visual()*
require("dial.map").inc_visual([group_name])

	VISUAL モードにおいて与えられたグループ名をもとにインクリメントを行うための
	キーシーケンスを出力します。

										*dial.map.dec_visual()*
require("dial.map").dec_visual([group_name])

	VISUAL モードにおいて与えられたグループ名をもとにデクリメントを行うための
	キーシーケンスを出力します。

										*dial.map.inc_gvisual()*
require("dial.map").inc_gvisual([group_name])

	VISUAL モードにおいて与えられたグループ名をもとにイデクリメントを行うため
	のキーシーケンスを出力します。被加数は上から順に [count] ずつ増加します。

										*dial.map.dec_gvisual()*
require("dial.map").dec_gvisual([group_name])

	VISUAL モードにおいて与えられたグループ名をもとにデクリメントを行うための
	キーシーケンスを出力します。被加数は上から順に [count] ずつ増加します。

"dial.augend" module~

被加数を定義するモジュールです。 |dial-augends| 参照。

"dial.config" module~

									*dial.config.augends:register_group()*
require("dial.config").augends:register_group(tbl)

	与えられた辞書形式のテーブルに基づいてグループを定義または上書きします。
	関数の引数には、グループ名をキー、被加数のリストを値とする辞書を指定します。

									*dial.config.augends:get()*
require("dial.config").augends:get(group_name)

	登録されているグループのうち、 `group_name` をグループ名にもつものを取得し
	ます。

vim:tw=78:fo=tcq2mM:ts=4:ft=help:norl:noet:fdm=marker:fen
